import{B as e,a as r,V as t,v as o,m as i,a9 as a,ai as n,ab as s,ac as u}from"./three.module-98a4b09c.js";var l={computeTangents:function(o){var i=o.index,a=o.attributes;if(null!==i&&void 0!==a.position&&void 0!==a.normal&&void 0!==a.uv){var n=i.array,s=a.position.array,u=a.normal.array,l=a.uv.array,f=s.length/3;void 0===a.tangent&&o.setAttribute("tangent",new e(new Float32Array(4*f),4));for(var m=a.tangent.array,g=[],d=[],c=0;c<f;c++)g[c]=new r,d[c]=new r;var h=new r,b=new r,v=new r,y=new t,p=new t,A=new t,w=new r,E=new r,B=o.groups;0===B.length&&(B=[{start:0,count:n.length}]);c=0;for(var T=B.length;c<T;++c)for(var x=I=(M=B[c]).start,G=I+M.count;x<G;x+=3)k(n[x+0],n[x+1],n[x+2]);var U,S,R,z=new r,H=new r,X=new r,D=new r;for(c=0,T=B.length;c<T;++c){var M,I;for(x=I=(M=B[c]).start,G=I+M.count;x<G;x+=3)V(n[x+0]),V(n[x+1]),V(n[x+2])}}else console.error("THREE.BufferGeometryUtils: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");function k(e,r,t){h.fromArray(s,3*e),b.fromArray(s,3*r),v.fromArray(s,3*t),y.fromArray(l,2*e),p.fromArray(l,2*r),A.fromArray(l,2*t),b.sub(h),v.sub(h),p.sub(y),A.sub(y);var o=1/(p.x*A.y-A.x*p.y);isFinite(o)&&(w.copy(b).multiplyScalar(A.y).addScaledVector(v,-p.y).multiplyScalar(o),E.copy(v).multiplyScalar(p.x).addScaledVector(b,-A.x).multiplyScalar(o),g[e].add(w),g[r].add(w),g[t].add(w),d[e].add(E),d[r].add(E),d[t].add(E))}function V(e){X.fromArray(u,3*e),D.copy(X),S=g[e],z.copy(S),z.sub(X.multiplyScalar(X.dot(S))).normalize(),H.crossVectors(D,S),R=H.dot(d[e]),U=R<0?-1:1,m[4*e]=z.x,m[4*e+1]=z.y,m[4*e+2]=z.z,m[4*e+3]=U}},mergeBufferGeometries:function(e,r){for(var t=null!==e[0].index,i=new Set(Object.keys(e[0].attributes)),a=new Set(Object.keys(e[0].morphAttributes)),n={},s={},u=e[0].morphTargetsRelative,l=new o,f=0,m=0;m<e.length;++m){var g=e[m],d=0;if(t!==(null!==g.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(var c in g.attributes){if(!i.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+'. All geometries must have compatible attributes; make sure "'+c+'" attribute exists among all geometries, or in none of them.'),null;void 0===n[c]&&(n[c]=[]),n[c].push(g.attributes[c]),d++}if(d!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". Make sure all geometries have the same number of attributes."),null;if(u!==g.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(var c in g.morphAttributes){if(!a.has(c))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===s[c]&&(s[c]=[]),s[c].push(g.morphAttributes[c])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(g.userData),r){var h;if(t)h=g.index.count;else{if(void 0===g.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+m+". The geometry must have either an index or a position attribute"),null;h=g.attributes.position.count}l.addGroup(f,h,m),f+=h}}if(t){var b=0,v=[];for(m=0;m<e.length;++m){for(var y=e[m].index,p=0;p<y.count;++p)v.push(y.getX(p)+b);b+=e[m].attributes.position.count}l.setIndex(v)}for(var c in n){var A=this.mergeBufferAttributes(n[c]);if(!A)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+c+" attribute."),null;l.setAttribute(c,A)}for(var c in s){var w=s[c][0].length;if(0===w)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[c]=[];for(m=0;m<w;++m){var E=[];for(p=0;p<s[c].length;++p)E.push(s[c][p][m]);var B=this.mergeBufferAttributes(E);if(!B)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+c+" morphAttribute."),null;l.morphAttributes[c].push(B)}}return l},mergeBufferAttributes:function(r){for(var t,o,i,a=0,n=0;n<r.length;++n){var s=r[n];if(s.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===t&&(t=s.array.constructor),t!==s.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===o&&(o=s.itemSize),o!==s.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=s.normalized),i!==s.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;a+=s.array.length}var u=new t(a),l=0;for(n=0;n<r.length;++n)u.set(r[n].array,l),l+=r[n].array.length;return new e(u,o,i)},interleaveAttributes:function(e){for(var r,t=0,o=0,n=0,s=e.length;n<s;++n){var u=e[n];if(void 0===r&&(r=u.array.constructor),r!==u.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;t+=u.array.length,o+=u.itemSize}var l=new i(new r(t),o),f=0,m=[],g=["getX","getY","getZ","getW"],d=["setX","setY","setZ","setW"],c=0;for(s=e.length;c<s;c++){var h=(u=e[c]).itemSize,b=u.count,v=new a(l,h,f,u.normalized);m.push(v),f+=h;for(var y=0;y<b;y++)for(var p=0;p<h;p++)v[d[p]](y,u[g[p]](y))}return m},estimateBytesUsed:function(e){var r=0;for(var t in e.attributes){var o=e.getAttribute(t);r+=o.count*o.itemSize*o.array.BYTES_PER_ELEMENT}var i=e.getIndex();return r+=i?i.count*i.itemSize*i.array.BYTES_PER_ELEMENT:0},mergeVertices:function(r,t=1e-4){t=Math.max(t,Number.EPSILON);for(var o={},i=r.getIndex(),a=r.getAttribute("position"),n=i?i.count:a.count,s=0,u=Object.keys(r.attributes),l={},f={},m=[],g=["getX","getY","getZ","getW"],d=0,c=u.length;d<c;d++){l[A=u[d]]=[],(T=r.morphAttributes[A])&&(f[A]=new Array(T.length).fill().map((()=>[])))}var h=Math.log10(1/t),b=Math.pow(10,h);for(d=0;d<n;d++){var v=i?i.getX(d):d,y="",p=0;for(c=u.length;p<c;p++)for(var A=u[p],w=(B=r.getAttribute(A)).itemSize,E=0;E<w;E++)y+=~~(B[g[E]](v)*b)+",";if(y in o)m.push(o[y]);else{for(p=0,c=u.length;p<c;p++){A=u[p];var B=r.getAttribute(A),T=r.morphAttributes[A],x=(w=B.itemSize,l[A]),G=f[A];for(E=0;E<w;E++){var U=g[E];if(x.push(B[U](v)),T)for(var S=0,R=T.length;S<R;S++)G[S].push(T[S][U](v))}}o[y]=s,m.push(s),s++}}const z=r.clone();for(d=0,c=u.length;d<c;d++){A=u[d];var H=r.getAttribute(A),X=new H.array.constructor(l[A]);B=new e(X,H.itemSize,H.normalized);if(z.setAttribute(A,B),A in f)for(p=0;p<f[A].length;p++){var D=r.morphAttributes[A][p],M=(X=new D.array.constructor(f[A][p]),new e(X,D.itemSize,D.normalized));z.morphAttributes[A][p]=M}}return z.setIndex(m),z},toTrianglesDrawMode:function(e,r){if(r===n)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),e;if(r===s||r===u){var t=e.getIndex();if(null===t){var o=[],i=e.getAttribute("position");if(void 0===i)return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),e;for(var a=0;a<i.count;a++)o.push(a);e.setIndex(o),t=e.getIndex()}var l=t.count-2,f=[];if(r===s)for(a=1;a<=l;a++)f.push(t.getX(0)),f.push(t.getX(a)),f.push(t.getX(a+1));else for(a=0;a<l;a++)a%2==0?(f.push(t.getX(a)),f.push(t.getX(a+1)),f.push(t.getX(a+2))):(f.push(t.getX(a+2)),f.push(t.getX(a+1)),f.push(t.getX(a)));f.length/3!==l&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");var m=e.clone();return m.setIndex(f),m.clearGroups(),m}return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",r),e}};export{l as B};
