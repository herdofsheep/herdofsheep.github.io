<html>

  <head>
    <title>witchcraft web dev</title>
    <link rel="stylesheet" href="/up_/src/artPortfolio/witchcraftWebdev.e1422d98.css" type="text/css" charset="utf-8">
    <script src="/up_/src/art.eedf5a3f.js"></script>
  </head>

  <style>body {
  cursor: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAJzGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDggNzkuMTY0MDM2LCAyMDE5LzA4LzEzLTAxOjA2OjU3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHhtcDpDcmVhdGVEYXRlPSIyMDIxLTAxLTAxVDIyOjQ1OjI2WiIgeG1wOk1vZGlmeURhdGU9IjIwMjEtMDEtMDFUMjI6NDg6NDdaIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIxLTAxLTAxVDIyOjQ4OjQ3WiIgZGM6Zm9ybWF0PSJpbWFnZS9wbmciIHBob3Rvc2hvcDpDb2xvck1vZGU9IjMiIHBob3Rvc2hvcDpJQ0NQcm9maWxlPSJzUkdCIElFQzYxOTY2LTIuMSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo1MjRjZWE1OC1hMTAzLTQ3MjUtYTY0Mi1jMjA1YmY3NGFkMzUiIHhtcE1NOkRvY3VtZW50SUQ9ImFkb2JlOmRvY2lkOnBob3Rvc2hvcDozNzZlNDFjZi1jNDE0LWExNGEtOTZmMi02YjVmZTMxMTcwN2YiIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozMjQ1ODFmMi1lZDkyLTQyMDktODFiOS03NTY4YmFhODBkOTciPiA8eG1wTU06SGlzdG9yeT4gPHJkZjpTZXE+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjcmVhdGVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOjMyNDU4MWYyLWVkOTItNDIwOS04MWI5LTc1NjhiYWE4MGQ5NyIgc3RFdnQ6d2hlbj0iMjAyMS0wMS0wMVQyMjo0NToyNloiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMS4wIChNYWNpbnRvc2gpIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJjb252ZXJ0ZWQiIHN0RXZ0OnBhcmFtZXRlcnM9ImZyb20gaW1hZ2UvcG5nIHRvIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AiLz4gPHJkZjpsaSBzdEV2dDphY3Rpb249InNhdmVkIiBzdEV2dDppbnN0YW5jZUlEPSJ4bXAuaWlkOmU0NTkxMTI5LWEwZjUtNDcyOS1iOGQ3LTFjYzM0NzUwNGUwMyIgc3RFdnQ6d2hlbj0iMjAyMS0wMS0wMVQyMjo0ODoyMFoiIHN0RXZ0OnNvZnR3YXJlQWdlbnQ9IkFkb2JlIFBob3Rvc2hvcCAyMS4wIChNYWNpbnRvc2gpIiBzdEV2dDpjaGFuZ2VkPSIvIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJzYXZlZCIgc3RFdnQ6aW5zdGFuY2VJRD0ieG1wLmlpZDphMDY2NWY0OC01NGExLTQxMmEtYjBkNS1hODA2YjUxZjk3MTUiIHN0RXZ0OndoZW49IjIwMjEtMDEtMDFUMjI6NDg6NDdaIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0iY29udmVydGVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJmcm9tIGFwcGxpY2F0aW9uL3ZuZC5hZG9iZS5waG90b3Nob3AgdG8gaW1hZ2UvcG5nIi8+IDxyZGY6bGkgc3RFdnQ6YWN0aW9uPSJkZXJpdmVkIiBzdEV2dDpwYXJhbWV0ZXJzPSJjb252ZXJ0ZWQgZnJvbSBhcHBsaWNhdGlvbi92bmQuYWRvYmUucGhvdG9zaG9wIHRvIGltYWdlL3BuZyIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NTI0Y2VhNTgtYTEwMy00NzI1LWE2NDItYzIwNWJmNzRhZDM1IiBzdEV2dDp3aGVuPSIyMDIxLTAxLTAxVDIyOjQ4OjQ3WiIgc3RFdnQ6c29mdHdhcmVBZ2VudD0iQWRvYmUgUGhvdG9zaG9wIDIxLjAgKE1hY2ludG9zaCkiIHN0RXZ0OmNoYW5nZWQ9Ii8iLz4gPC9yZGY6U2VxPiA8L3htcE1NOkhpc3Rvcnk+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOmEwNjY1ZjQ4LTU0YTEtNDEyYS1iMGQ1LWE4MDZiNTFmOTcxNSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDozMjQ1ODFmMi1lZDkyLTQyMDktODFiOS03NTY4YmFhODBkOTciIHN0UmVmOm9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDozMjQ1ODFmMi1lZDkyLTQyMDktODFiOS03NTY4YmFhODBkOTciLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4oan54AAABmklEQVRIx63Vz0sWURTG8XnxzfK1KCLbZZQIBbnIooWroH1/RIu2/QvSql1U4NZFtDJICFH6IUpCOw2lXZswRAzaZAsV+7Q5Q8Nl5v194MA9d+483znPvTOTIWuSN3C2xZqm2WrBEzzsF+AyBpMF3/A5mRvFtW4A4/iBaVzALf/jOi7hGfZwrluLXobgH2wWAFs4iPHzXvZgHEeq4xhjvQAu4ksTwHdModYJ4ATu4w0OK4S/JvU2nuJOO4DbmImbymIadcwV5jbwCCOdWFTDJD4lT16P6zlkC6e73YOT2E06eB02ZhjAK6zhTDeAByH6F+sFyFxJJysY7tSiTczjJk7hVwB+JpCrUS+j0S5gJISLcy/ivbiC1RB9jN+4G/XHZpBWHk7iQ4wbIZbHPu7FnqxW2dXOSZjC+RgPhy15FDt5F7Z2DBiIrFV0UoQspZBUrFZS10uuNfC+ArIYx73tDqpyKGwpgyzkkF4AOWSpAvIWg70CsvB8sQSyhtl+APJPzEJyhHcw0S9AFv/z+QDsYaIfe1AGmc3Fkf0DcIZCeRD8km8AAAAASUVORK5CYII="), auto;
  background-image: url("../../../shroms.c5052a42.png");
}

h {
  color: #fff;
  text-align: center;
  font-size: 50px;
}

.littleImg {
  width: 300px;
}

.box {
  border: 10px double #fff;
  width: 90%;
  margin-bottom: 30px;
  display: inline-block;
  position: relative;
}

.box:before, .box:after {
  content: "•";
  color: #fff;
  border: 2px solid #fff;
  width: 14px;
  height: 14px;
  font-size: 14px;
  display: block;
  position: absolute;
}

.box:before {
  top: 0;
}

.box:after {
  bottom: 0;
}

.box-inner {
  border: 2px solid #fff;
  margin: 18px;
  padding: 5px;
}

.box-inner:before, .box-inner:after {
  content: "•";
  color: #fff;
  border: 2px solid #fff;
  width: 14px;
  height: 14px;
  font-size: 14px;
  display: block;
  position: absolute;
  right: 0;
}

.box-inner:before {
  top: 0;
}

.box-inner:after {
  bottom: 0;
}
</style>
  
  <body>

    <script>// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"4Ex0H":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
var HMR_USE_SSE = false;
module.bundle.HMR_BUNDLE_ID = "d90e816ec2792ab4";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, HMR_USE_SSE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var HMR_USE_SSE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && ![
        "localhost",
        "127.0.0.1",
        "0.0.0.0"
    ].includes(hostname) ? "wss" : "ws";
    var ws;
    if (HMR_USE_SSE) ws = new EventSource("/__parcel_hmr");
    else try {
        ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    } catch (err) {
        if (err.message) console.error(err.message);
        ws = {};
    }
    // Web extension context
    var extCtx = typeof browser === "undefined" ? typeof chrome === "undefined" ? null : chrome : browser;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    if (ws instanceof WebSocket) {
        ws.onerror = function(e) {
            if (e.message) console.error(e.message);
        };
        ws.onclose = function() {
            console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
        };
    }
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] \u2728 Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          \u{1F6A8} ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>\u{1F4DD} <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension fix
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3 && typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                        extCtx.runtime.reload();
                        return;
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"9E5ZO":[function(require,module,exports) {
new fairyDustCursor({
    colors: [
        "#ffffff"
    ]
});

},{}]},["4Ex0H","9E5ZO"], "9E5ZO", "parcelRequire26b9")

</script>

    <div class="contents">
        <div class="textWindow">
            <h>Witchcraft Web Dev</h>
        </div>

        <div class="textWindow">
        <div class="text margin">
            This page is a ritual to guide artists to building a web page hosting their own images, text and links. With a bit of independent learning it is perfectly possible to work with the many wonders of the modern web including 3D things, playable games and interactive experiences.<br><br>
            To begin we will be starting small, no knowledge of any kind of programming is necessary. We will be building a website from nothing where we can host images as a personal gallery. <br><br>
            To see some of what can be done with a little coding knowledge, check out my website <a href="https://www.meganbat.es/">here</a> of which you can read the entirety of the code running it <a href="https://github.com/herdofsheep/herdofsheep.github.io" target="_blank">here.</a><br><br>
            The web has a high barrier for entry, there is a lot of money in keeping the internet expensive, mysterious and inaccessible, and part of that is in the language we use to describe it. <br><br>
            In this ritual, We will be simulatenously be leaning web development 101, and using a mental framework to approach web development from an unusual perspective- using witchcraft to manifest a link for ourselves in the online web. <br><br>
            The entire exercise is free, and will end with us having a web page, which we can customise to the limits of how much code/spellcasting we are willing to learn. This is not squarespace or livejournal- everything will run on our own code, and there are no constraints to what we can do, other than what is currently possible on the internet, and 2GB of storage space (loads!).<br><br>
            I will encourage you to learn some of the 'tech' language to be able to speak in the internet's tongue, but also think of creating a website in an unconventional way.
        </div>
        </div>
        
        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/1.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/1.png" alt="github splashscreen"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
        <div class="text margin">
            github is a space on the internet you may have heard of- it is largely an organisational space for a tool called 'git'. Its extremely useful, but we won't be using it in a great amount of detail here. <br><br>
            Each github account provides you with a free web domain, where we can 'host' our code, and manifest the spell we are casting- to command a space on the web, where anyone can visit and experience the web page which we have manifested. <br><br>
            We need to create a unique name for our account, which will also be the 'address' url which will be used to find our link. <br><br>
            For deciding on your url- try thinking about what it is you are hoping to manifest. Will it be a place to showcase your art? Somewhere to experiment and make work with the medium of code? A place to write down your thoughts?
        </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/2.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/2.png" alt="naming our domain">
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
        <div class="text margin">
            you could think about:
            <ul>
                <li>the web as an invisible entangled connection between thousands of individuals, similar to a fungal blanket connecting trees in an ancient forest.</li> <br>
                <li>the web as a word associated with spiders, capturing and entrapping data and hours of time of people, encircling the whole world.</li> <br>
                <li>the web as a social project, the effort of thousands, all contributing to an enormous collaboration. The organising of enormous amounts of complex work in a way which is trying to constantly grow and innovate, without breaking the millions of web projects which have been built since 1989.</li> <br>
                <li>
                    the act of writing code (which we will think of in this workshop as 'spell writing'), the tapestry weaving of connecting logic, the feminine history of developing programming-
                    <a href="https://en.wikipedia.org/wiki/Women_in_computing" target="_blank">Ada Lovelace, Grace Hopper, the women of Bletchley Park.</a>
                </li>
            </ul>

        </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/3.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/3.png" alt="confirming email">
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                We now, in order to proceed, need to confirm our email address. It is best not to take this decision lightly- github is owned by Microsoft. <br><br>
                The hierarchical accumulation of data is an important concern. Now is a good moment to try and visualise this accumulation of data, information, currency, power, concentrated in locuses like Amazon, Apple, Microsoft, Google. <br><br>
                Remember our goal- what are we manifesting? A space in this interconnected web for ourselves, free and accessible to us and to those we share it with. Is data harvesting a price worth paying for access to this powerful online space? Perhaps think on collective responsibility, grass roots power. Perhaps you want to do a little research into this yourself.
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/4a.png">
                        <img class="img littleImg" src="/up_/src/artPortfolio/witchcraftWebDev/4a.png" alt="creating a repo button">
                    </a>
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/4.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/4.png" alt="creating a repo"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                We now, in the words of github, create a 'repository'. We can think of this as a host to hold our spell, a location in the web, in github's information storage and (if we want) a file location on our computer simulataneously. <br><br>
                What makes it a 'repository' is the linking of these things, which makes our spell (aka our code) consistent in all of these different forms. That is essentially all that 'git' is. <br><br>
                In order for this repository to be treated as a website, it must use the free domain that you get associated with your github account as the name. For me, it is manifestation-spell.github.io. For you, it will be USERNAME-YOU-CHOSE.github.io
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/5.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/5.png" alt="create a new file button"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                Click on 'creating a new file'
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/6.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/6.png" alt="commit your first file part 1"> 
                    </a>
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/7.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/7.png" alt="commit your first file part 2"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                Name your new file index.html, with the contents <br><br> <div class="code margin">I will these words to appear.</div> <br><br>  Then, click on 'Commit new file'.<br><br>
                An index.html is a universally understood gateway to a website. It will be understood by an 'internet browser' (firefox, chrome, edge, safari) to be the place where a website begins. This has worked since the early days of the web and will do into the future of the internet!
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/8.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/8.png" alt="working website"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                You can now navigate to the host of your spell. This will be USERNAME-YOU-CHOSE.github.io. You can look at mine here: 
                <a href="https://manifestation-spell.github.io/" target="_blank">manifestation-spell.github.io</a><br><br>
                We now have everything set up to host a web page! We can write any HTML in this file and it will function as a web page for us to use however we like, and share with anyone! Very exciting, you are on your fist step as a software developer, tech witch, and web artist!
                Bear with if you get a 404 error at first- github pages sometimes takes a while to update. If you have a blank page, your code has an error (and read on to learn how to 'debug' with inspect), if you have a 404, github pages is just taking a moment to update.
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/404.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/404.png" alt="github 404 error"> 
                    </a>
                </div>
            </div>
        </div>
        
        <div class="textWindow">
            <div class="text margin">
                But wait, what is HTML?
                <a href="https://www.w3schools.com/html/html_basic.asp" target="_blank">W3Schools</a>
                is a brilliant place to start.<br><br>
                The most important lesson in learning to be an internet witch is that you can learn how to do anything, if you are patient and dedicated enough. The thing that is difficult is getting started. Once you can learn how to learn, You can build a piece of the internet yourself- we've already begun.
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/12.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/12.png" alt="W3Schools on images"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                Within the <a href="https://www.w3schools.com/html/html_basic.asp" target="_blank">W3Schools</a> link, you can scroll to find the information on including images in HTML. We wanted to make a gallery of our art, so to include images, this is the form which our spell must take. <br><br>
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/9.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/9.png" alt="commit your first file part 1">
                    </a>
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/10.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/10.png" alt="commit your first file part 2"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                To adapt the code to manifest a painting of mine instead of a w3schools logo, I must change key elements of the line of code. W3Schools uses <br><br>
                <div class="code margin">&ltimg src="w3schools.jpg" alt="W3Schools.com" width="104" height="142"&gt </div><br><br>
                and I use <br><br>
                <div class="code margin">&ltimg src="artwork.jpg" alt="a painting by Megan Bates of a computer generated rippling water pool with mushrooms" width="100%"&gt </div><br><br>
                we can save this line of code in index.html to replace<br><br> <div class="code margin">I will these words to appear.</div> <br><br>
                But I have saved this code in a new file, artwork-portal.html. It can be accessed at <a href="https://manifestation-spell.github.io/artwork-portal.html" target="_blank">manifestation-spell.github.io/artwork-portal.html</a>
                However, something unexpected has happened- instead of any image, there is just my alt text, 'a painting by Megan Bates of a computer generated rippling water pool with mushrooms'. <br><br>
                This begins to show us why it is always important to use alt text when including images on our website- if the image can't by found, we get context explaining what should be there. This is incredibly important for blind users of the internet- often images are essential for basic web navigation, and so you must provide a clear explanation of what each of the images on your website are, and what their function is (if they have one).
                Accessibility is an essential part of internet spellcasting- our disabled siblings, sisters and brothers must be included in the web which we build. <br><br>
                We need to find out where our image is- to find out what is going on, we will use the 'inspect' tool. <br> <br>
                This is slightly different depending on which browser you use, but all are similar. I will be using firefox's inspect, which can be opened using a right-click > Inspect element or CTRL+SHIFT+C on Windows or CMD+SHIFT+C on Mac.
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/11.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/11.png" alt="seeing your new web page"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                Within the inspector- we can see we have 2 errors. One is for a jpg image- it can't be found, and the other is for something called a favicon. What is that? If we think about it- this makes perfect sense.
                What image indeed? We haven't put an image on to github for our site to access yet. Let's do that now. <br><br> 
                (for the curious,
                <a href="https://favicon.io/tutorials/what-is-a-favicon/">look here for an explanation on favicons.</a> There's no rush to include one right away, they aren't necessary for our website to work.)
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/13.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/13.png" alt="seeing your new web page"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                To add our image, we just add it to our github repository as shown:
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/14.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/14.png" alt="seeing your new web page"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/15.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/15.png" alt="seeing your new web page"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="box">
                <div class="box-inner">
                    <a href="/up_/src/artPortfolio/witchcraftWebDev/16.png">
                        <img class="img full" src="/up_/src/artPortfolio/witchcraftWebDev/16.png" alt="seeing your new web page"> 
                    </a>
                </div>
            </div>
        </div>

        <div class="textWindow">
            <div class="text margin">
                In order for our html page to find this image, it needs to be named correctly. We will remember that the code we used was <br><br>
                <div class="code margin">&ltimg src="artwork.jpg" alt="a painting by Megan Bates of a computer generated rippling water pool with mushrooms" width="100%"&gt </div><br><br>
                so we should make sure that the src=" " quotes contents is correct. src is a link source, which locates a url location on the internet to find the image. Now we have uploaded it, the failsafe source of the image is <a href="https://manifestation-spell.github.io/ripple.jpg" target="_blank">https://manifestation-spell.github.io/ripple.jpg</a>
                HTML is clever enough to be able to find an image locally however. Using <br><br>
                <div class="code margin">&ltimg src="ripple.jpg" alt="a painting by Megan Bates of a computer generated rippling water pool with mushrooms" width="100%"&gt </div><br><br>
                will work fine.<br><br>
                To create this linked page, I will create yet another html page, <a href="https://manifestation-spell.github.io/linked-artwork-portal.html" target="_blank">manifestation-spell.github.io/linked-artwork-portal.html</a> which hosts the single line of code above, with the correct name of the image in the src=" " quotes. Now is a good moment to experiment and test what does and doesn't work- what if we use the full url addresss of the image, 
                'https://manifestation-spell.github.io/ripple.jpg' in the src=" " quotes instead? What happens if we rename the image itself? What do I do once I've got 100 images? Or 100 html pages? Won't it get a bit messy having them all here? Can I have text and an image? Does it still work if I name this spell index.html? 
            </div>
        </div>
    </div>
    
  </body>
  
</html>
